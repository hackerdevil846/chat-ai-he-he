const fs = require("fs-extra");
const path = require("path");
const axios = require("axios");
const Jimp = require("jimp");

module.exports.config = {
	name: "love6",
	version: "1.0.0",
	hasPermssion: 0,
	credits: "ùë®ùíîùíäùíá ùë¥ùíÇùíâùíéùíñùíÖ",
	description: "‚ú® Create romantic love image with two users",
	category: "love",
	usages: "[tag]",
	cooldowns: 5,
	dependencies: {
		"axios": "",
		"fs-extra": "",
		"path": "",
		"jimp": ""
	}
};

module.exports.onLoad = async function () {
    const cacheDir = path.join(__dirname, "cache");
    const baseImagePath = path.join(cacheDir, "love_template.png");
    
    if (!fs.existsSync(cacheDir)) {
        await fs.mkdir(cacheDir, { recursive: true });
    }

    if (!fs.existsSync(baseImagePath)) {
        try {
            const url = 'https://drive.google.com/uc?export=download&id=1BZu-1GS5DMiuQHtcdZNmY4-ayiOwVyI3';
            const response = await axios.get(url, { responseType: 'arraybuffer' });
            await fs.writeFile(baseImagePath, response.data);
            console.log("üå∏ Base image downloaded successfully");
        } catch (error) {
            console.error("‚ùå Error downloading base image:", error);
        }
    }
};

module.exports.run = async function ({ event, api, args }) {
    const { threadID, messageID, senderID, mentions } = event;

    if (Object.keys(mentions).length === 0) {
        return api.sendMessage('üíù Please tag 1 person to create love image', threadID, messageID);
    }

    const mentionedUserID = Object.keys(mentions)[0];
    const mentionedName = mentions[mentionedUserID].replace(/@/g, '');

    try {
        api.sendMessage("üîÑ Creating love image...", threadID, messageID);
        
        const imageBuffer = await generateLoveImage(senderID, mentionedUserID);
        const message = {
            body: `üíû ${mentionedName} love you so much! üíë\n\n- Generated by: ùë®ùíîùíäùíá ùë¥ùíÇùíâùíéùíñùíÖ`,
            mentions: [{
                tag: mentionedName,
                id: mentionedUserID
            }],
            attachment: fs.createReadStream(imageBuffer)
        };

        api.sendMessage(message, threadID, () => fs.unlinkSync(imageBuffer), messageID);
    } catch (error) {
        console.error("‚ùå Error:", error);
        api.sendMessage("‚ùå Failed to create love image. Please try again later.", threadID, messageID);
    }
};

async function generateLoveImage(user1ID, user2ID) {
    const cacheDir = path.join(__dirname, 'cache');
    const baseImagePath = path.join(cacheDir, 'love_template.png');

    const downloadAvatar = async (userID) => {
        const avatarPath = path.join(cacheDir, `avatar_${userID}.png`);
        const sources = [
            `https://graph.facebook.com/${userID}/picture?width=512&height=512&access_token=6628568379%7Cc1e620fa708a1d5696fb991c1bde5662`,
            `https://graph.facebook.com/${userID}/picture?width=512&height=512`,
            `https://graph.facebook.com/v19.0/${userID}/picture?width=512&height=512`
        ];

        for (const source of sources) {
            try {
                const response = await axios.get(source, { responseType: 'arraybuffer' });
                await fs.writeFile(avatarPath, response.data);
                return await Jimp.read(avatarPath);
            } catch (error) {
                continue;
            }
        }
        throw new Error("Cannot download avatar");
    };

    try {
        const baseImage = await Jimp.read(baseImagePath);
        const [avatar1, avatar2] = await Promise.all([
            downloadAvatar(user1ID),
            downloadAvatar(user2ID)
        ]);

        const processAvatar = (avatar) => {
            const size = Math.min(avatar.bitmap.width, avatar.bitmap.height);
            return avatar
                .crop(0, 0, size, size)
                .resize(200, 200)
                .circle();
        };

        const processedAvatar1 = processAvatar(avatar1);
        const processedAvatar2 = processAvatar(avatar2);

        baseImage
            .resize(1200, 800)
            .composite(processedAvatar1, 300, 350)
            .composite(processedAvatar2, 800, 350);

        const outputPath = path.join(cacheDir, `love_${user1ID}_${user2ID}_${Date.now()}.png`);
        await baseImage.writeAsync(outputPath);

        // Cleanup avatars
        [user1ID, user2ID].forEach(id => {
            const avatarPath = path.join(cacheDir, `avatar_${id}.png`);
            if (fs.existsSync(avatarPath)) fs.unlinkSync(avatarPath);
        });

        return outputPath;
    } catch (error) {
        console.error("‚ùå Image generation error:", error);
        throw error;
    }
}
