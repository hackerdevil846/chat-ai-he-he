const axios = require('axios');
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');
const path = require('path');

// --- Configuration ---
module.exports.config = {
  name: "quranverse",
  aliases: ["verse", "quran", "ayah"],
  version: "2.0",
  hasPermssion: 0,
  credits: "ğ‘¨ğ’”ğ’Šğ’‡ ğ‘´ğ’‚ğ’‰ğ’ğ’–ğ’…",
  description: "Get Quran verses with translations and audio",
  category: "islam",
  usages: "[random] | audio | [surah]:[verse] | lang [code]",
  cooldowns: 10,
  dependencies: {
    "axios": "",
    "canvas": ""
  },
  envConfig: {}
};

// --- Language labels (for headers) ---
const LANGS = {
  en: 'English',
  ur: 'Urdu',
  ar: 'Arabic',
  bn: 'Bengali'
};

// expose for compatibility with other code expecting `languages` or `langs`
module.exports.languages = LANGS;
module.exports.langs = LANGS;

// Ensure tmp folder exists when the module loads
module.exports.onLoad = function () {
  try {
    const tmpDir = path.join(__dirname, '..', 'tmp');
    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
    console.log(`[quranverse] tmp directory ready: ${tmpDir}`);
  } catch (err) {
    console.error('[quranverse] Failed to create tmp directory:', err);
  }
};

// Some systems expect onStart as well â€” alias to onLoad to avoid "onStart undefined" errors
module.exports.onStart = module.exports.onLoad;

// --- Utility: wrap text for canvas ---
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  if (!text) return;
  const words = String(text).split(' ');
  let line = '';

  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth && n > 0) {
      ctx.fillText(line.trim(), x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line.trim(), x, y);
}

// --- Create the verse image ---
async function createVerseImage(verseData, language) {
  const width = 800;
  const height = 600;
  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');

  // Background gradient
  const gradient = ctx.createLinearGradient(0, 0, width, height);
  gradient.addColorStop(0, '#0c1e25');
  gradient.addColorStop(1, '#1d4a5d');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);

  // Decorative soft circles
  ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
  for (let i = 0; i < 20; i++) {
    ctx.beginPath();
    ctx.arc(
      Math.random() * width,
      Math.random() * height,
      Math.random() * 10 + 5,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Title
  ctx.font = 'bold 40px "Segoe UI"';
  ctx.fillStyle = '#f1c40f';
  ctx.textAlign = 'center';
  ctx.fillText('ğŸŒ™ Quran Verse ğŸŒ™', width / 2, 70);

  // Surah info
  ctx.font = '28px "Segoe UI"';
  ctx.fillStyle = '#e67e22';
  ctx.fillText(`${verseData.surahName} (${verseData.surahNameTranslation || ''})`, width / 2, 130);

  ctx.font = '22px "Segoe UI"';
  ctx.fillStyle = '#ecf0f1';
  ctx.fillText(`Surah ${verseData.surahNumber}:${verseData.verseNumber} | ${verseData.revelationPlace || ''}`, width / 2, 170);

  // Arabic text (centered) â€” use a font that supports Arabic if available
  ctx.font = 'bold 36px "Traditional Arabic"';
  ctx.fillStyle = '#2ecc71';
  ctx.textAlign = 'center';
  // if the Arabic string is long, we can split into multiple lines by newline
  const arabic = verseData.arabic1 || verseData.arabic || '';
  const arabicLines = String(arabic).split('\n');
  let arabicY = 240;
  for (const line of arabicLines) {
    ctx.fillText(line.trim(), width / 2, arabicY);
    arabicY += 36;
  }

  // Translation header
  ctx.font = 'italic 26px "Segoe UI"';
  ctx.fillStyle = '#3498db';
  ctx.fillText(`${LANGS[language] || LANGS.en} Translation:`, width / 2, 330);

  // Translation text
  const translation = verseData[language] || verseData.english || verseData.translation || '';
  ctx.font = '24px "Segoe UI"';
  ctx.fillStyle = '#ecf0f1';
  ctx.textAlign = 'center';
  wrapText(ctx, translation, width / 2, 380, 700, 34);

  // Footer
  ctx.font = '18px "Segoe UI"';
  ctx.fillStyle = '#bdc3c7';
  ctx.fillText('Generated by GoatBot â€¢ Credits: ğ‘¨ğ’”ğ’Šğ’‡ ğ‘´ğ’‚ğ’‰ğ’ğ’–ğ’…', width / 2, height - 30);

  // Save image to same path pattern as original (do not change path)
  const imagePath = path.join(__dirname, '..', 'tmp', `quran_${Date.now()}.png`);
  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync(imagePath, buffer);

  return imagePath;
}

// --- Main run handler ---
module.exports.run = async function ({ api, event, args }) {
  try {
    const actionRaw = args[0] ? String(args[0]).toLowerCase() : '';
    const wantsAudio = actionRaw === 'audio';
    const wantsLanguage = actionRaw === 'lang' && args[1];
    const wantsSpecific = /^\d+:\d+$/.test(actionRaw);

    if (wantsLanguage) {
      const langCode = String(args[1]).toLowerCase();
      if (LANGS[langCode]) {
        global.quranLanguage = langCode;
        return api.sendMessage(`âœ… Translation language set to ${LANGS[langCode]}`, event.threadID);
      }
      return api.sendMessage(`âŒ Invalid language. Available: ${Object.keys(LANGS).join(', ')}`, event.threadID);
    }

    const language = global.quranLanguage || 'en';

    // Fetch surah list
    const surahsResponse = await axios.get('https://quranapi.pages.dev/api/surah.json');
    if (!surahsResponse || !surahsResponse.data) throw new Error("Couldn't fetch surah list");

    const surahs = surahsResponse.data;
    let surahNumber, verseNumber;

    if (wantsSpecific) {
      [surahNumber, verseNumber] = actionRaw.split(':').map(Number);
    } else {
      // Pick a random surah
      const randomSurah = surahs[Math.floor(Math.random() * surahs.length)];
      surahNumber = randomSurah.number;
      // fetch surah details to determine verse count
      const surahDetail = await axios.get(`https://quranapi.pages.dev/api/${surahNumber}.json`);
      if (!surahDetail || !surahDetail.data) throw new Error("Couldn't fetch surah details");
      const totalVerses = (surahDetail.data.english || []).length || 1;
      verseNumber = Math.floor(Math.random() * totalVerses) + 1;
    }

    const verseResponse = await axios.get(`https://quranapi.pages.dev/api/${surahNumber}/${verseNumber}.json`);
    if (!verseResponse || !verseResponse.data) throw new Error("Couldn't fetch verse details");

    const verseData = verseResponse.data;
    verseData.surahNumber = surahNumber;
    verseData.verseNumber = verseNumber;

    // Create image
    const imagePath = await createVerseImage(verseData, language);

    // Compose message body
    let messageBody = `ğŸ“– ${verseData.surahName} (${verseData.surahNameTranslation || ''})\n` +
                      `Surah ${surahNumber}:${verseNumber} | ${verseData.revelationPlace || ''}\n\n` +
                      `"${verseData.arabic1 || verseData.arabic || ''}"\n\n` +
                      `*${LANGS[language] || LANGS.en} Translation:*\n${verseData[language] || verseData.english || ''}`;

    if (wantsAudio && verseData.audio) {
      const reciters = Object.values(verseData.audio || {});
      if (reciters.length) {
        messageBody += `\n\nğŸ§ Available Reciters:\n`;
        reciters.forEach((reciter, i) => {
          messageBody += `${i + 1}. ${reciter.reciter || reciter.name || 'Reciter'}\n`;
        });
        messageBody += `\nReply with number to hear recitation`;

        // Save options globally for handleReply
        global.quranAudioOptions = {
          reciters: reciters,
          verseInfo: `${verseData.surahName} ${surahNumber}:${verseNumber}`
        };
      }
    }

    await api.sendMessage({
      body: messageBody,
      attachment: fs.createReadStream(imagePath)
    }, event.threadID, () => {
      try { fs.unlinkSync(imagePath); } catch (e) {}
    });

  } catch (error) {
    console.error('[quranverse] Error in run:', error);
    api.sendMessage("âŒ An error occurred while fetching Quran verse. Please try again later.", event.threadID);
  }
};

// --- Handle replies (for audio selection) ---
module.exports.handleReply = async function ({ api, event }) {
  try {
    if (!global.quranAudioOptions || !event.body) return;

    const selectedNumber = parseInt(event.body);
    const { reciters, verseInfo } = global.quranAudioOptions;

    if (isNaN(selectedNumber)) return api.sendMessage("âŒ Please reply with a valid number.", event.threadID);
    if (selectedNumber < 1 || selectedNumber > reciters.length) {
      return api.sendMessage("âŒ Invalid selection. Please reply with a number from the list.", event.threadID);
    }

    const selectedReciter = reciters[selectedNumber - 1];
    const stream = await global.utils.getStreamFromURL(selectedReciter.url || selectedReciter.link);

    await api.sendMessage({
      body: `ğŸ§ Playing ${verseInfo} - ${selectedReciter.reciter || selectedReciter.name || 'Reciter'}`,
      attachment: stream
    }, event.threadID);

    // clean up
    delete global.quranAudioOptions;

  } catch (error) {
    console.error('[quranverse] handleReply error:', error);
    api.sendMessage("âŒ Failed to play the recitation. Please try again.", event.threadID);
  }
};

// Export an empty handleEvent in case the bot loader expects it
module.exports.handleEvent = function () {};
